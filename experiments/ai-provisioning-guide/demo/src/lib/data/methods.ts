import type { DeliveryMethod } from '../types.js';

export const methods: DeliveryMethod[] = [
  {
    id: 'byok',
    name: 'BYOK (Bring Your Own Key)',
    shortName: 'BYOK',
    category: 'User-Funded',
    tagline: 'Users pay with their own API keys',
    description:
      'Users provide their own API key for a commercial provider. Your product makes calls using their credentials.',
    bestFor: [
      'Power users with existing API keys',
      'Experimental tools and prototypes',
      'When WRI cannot subsidize usage',
    ],
    redFlags: [
      "Users don't have or want to manage API keys",
      'Inconsistent experience across users',
      'Support burden for key management issues',
    ],
    exampleServices: "User's own Claude/OpenAI key",
    characteristics: {
      costToWRI: 'none',
      costToUser: 'full',
      setupComplexity: 'low',
      operationalBurden: 'none',
      maxCapability: 'frontier',
      typicalLatency: { min: 200, max: 2000 },
      offlineCapable: false,
      dataLeavesDevice: true,
      dataLeavesWRI: true,
      queryVisibility: 'none',
      customGuardrails: 'none',
      vendorLockIn: 'low',
      multiProvider: true,
    },
  },
  {
    id: 'provider_direct',
    name: 'Provider Direct',
    shortName: 'Direct',
    category: 'Cloud-Hosted',
    tagline: 'Single provider, minimal wrapper',
    description:
      'WRI maintains an account with one provider (Anthropic, OpenAI, Google). Your product calls their API directly using WRI credentials.',
    bestFor: [
      'Production products with consistent UX',
      'Moderate volume (1K–50K/month)',
      'Fast time-to-market',
    ],
    redFlags: [
      'Runaway costs without monitoring',
      'Single point of failure',
      'No custom guardrails or routing',
    ],
    exampleServices: 'Anthropic, OpenAI, Google AI',
    characteristics: {
      costToWRI: 'per-token',
      costToUser: 'none',
      setupComplexity: 'low',
      operationalBurden: 'low',
      maxCapability: 'frontier',
      typicalLatency: { min: 200, max: 2000 },
      offlineCapable: false,
      dataLeavesDevice: true,
      dataLeavesWRI: true,
      queryVisibility: 'limited',
      customGuardrails: 'none',
      vendorLockIn: 'high',
      multiProvider: false,
    },
  },
  {
    id: 'managed_router',
    name: 'Managed Router',
    shortName: 'Router',
    category: 'Cloud-Hosted',
    tagline: 'Multi-provider with outsourced routing',
    description:
      'Third-party service provides a unified API across multiple providers with automatic fallbacks and consolidated billing.',
    bestFor: [
      'Multi-model experimentation',
      'Automatic provider fallbacks',
      'Consolidated billing across providers',
    ],
    redFlags: [
      'Token markup adds cost at scale',
      'Third-party sees all queries',
      'Limited custom guardrails',
    ],
    exampleServices: 'OpenRouter, Portkey, LiteLLM Gateway',
    characteristics: {
      costToWRI: 'per-token-plus-markup',
      costToUser: 'none',
      setupComplexity: 'low',
      operationalBurden: 'low',
      maxCapability: 'frontier',
      typicalLatency: { min: 250, max: 2500 },
      offlineCapable: false,
      dataLeavesDevice: true,
      dataLeavesWRI: true,
      queryVisibility: 'limited',
      customGuardrails: 'limited',
      vendorLockIn: 'medium',
      multiProvider: true,
    },
  },
  {
    id: 'self_built_proxy',
    name: 'Self-Built Proxy',
    shortName: 'Proxy',
    category: 'Cloud-Hosted',
    tagline: 'WRI-controlled routing + guardrails',
    description:
      'WRI operates middleware that routes requests to providers, adding guardrails, logging, rate limiting, and custom logic.',
    bestFor: [
      'Multi-tenant governance (per-team budgets)',
      'Custom guardrails and content filtering',
      'Detailed audit logging and usage tracking',
    ],
    redFlags: [
      'Over-engineering for simple use cases',
      'Added latency from proxy hop',
      'More infrastructure to maintain',
    ],
    exampleServices: 'Custom proxy on WRI infrastructure',
    characteristics: {
      costToWRI: 'per-token-plus-infra',
      costToUser: 'none',
      setupComplexity: 'medium',
      operationalBurden: 'medium',
      maxCapability: 'frontier',
      typicalLatency: { min: 300, max: 2500 },
      offlineCapable: false,
      dataLeavesDevice: true,
      dataLeavesWRI: true,
      queryVisibility: 'full',
      customGuardrails: 'full',
      vendorLockIn: 'medium',
      multiProvider: true,
    },
  },
  {
    id: 'managed_inference',
    name: 'Managed Inference',
    shortName: 'Managed',
    category: 'WRI-Hosted',
    tagline: 'Open models, managed infrastructure',
    description:
      'Third-party hosts open models on their infrastructure. Pay per inference without managing GPUs.',
    bestFor: [
      'High-volume open model usage',
      'Cost-sensitive workloads',
      'Teams without ML infrastructure skills',
    ],
    redFlags: [
      'Frontier quality not available',
      'Provider still sees your data',
      'Model availability can be spotty',
    ],
    exampleServices: 'Replicate, Together AI, Fireworks, Modal',
    characteristics: {
      costToWRI: 'per-token',
      costToUser: 'none',
      setupComplexity: 'low',
      operationalBurden: 'low',
      maxCapability: 'strong',
      typicalLatency: { min: 100, max: 500 },
      offlineCapable: false,
      dataLeavesDevice: true,
      dataLeavesWRI: true,
      queryVisibility: 'limited',
      customGuardrails: 'none',
      vendorLockIn: 'low',
      multiProvider: false,
    },
  },
  {
    id: 'full_self_hosted',
    name: 'Full Self-Hosted',
    shortName: 'Selfhosted',
    category: 'WRI-Hosted',
    tagline: 'Your infra, your models, your ops',
    description:
      'WRI runs models on its own infrastructure with full control over the stack. Requires GPU provisioning and ML ops.',
    bestFor: [
      'Very high predictable volume',
      'Data cannot leave WRI infrastructure',
      'Full control over models and pipeline',
    ],
    redFlags: [
      'Underestimating operational burden',
      'GPU capacity planning challenges',
      'Requires ML infrastructure expertise',
    ],
    exampleServices: 'vLLM on AWS, Ollama on EC2',
    characteristics: {
      costToWRI: 'infrastructure',
      costToUser: 'none',
      setupComplexity: 'high',
      operationalBurden: 'high',
      maxCapability: 'strong',
      typicalLatency: { min: 100, max: 500 },
      offlineCapable: false,
      dataLeavesDevice: true,
      dataLeavesWRI: false,
      queryVisibility: 'full',
      customGuardrails: 'full',
      vendorLockIn: 'none',
      multiProvider: false,
    },
  },
  {
    id: 'edge_browser',
    name: 'Edge / Browser',
    shortName: 'Edge',
    category: 'Edge/Client',
    tagline: 'On-device inference, no server calls',
    description:
      'Small models run in the user\'s browser via WebGPU/WASM or on their device. No server calls needed.',
    bestFor: [
      'Offline-first applications',
      'Privacy-critical features',
      'Simple tasks (classification, extraction)',
    ],
    redFlags: [
      'Overestimating small model capabilities',
      'Device fragmentation and compatibility',
      'Large model download for users',
    ],
    exampleServices: 'WebLLM, Transformers.js, Phi-3',
    characteristics: {
      costToWRI: 'none',
      costToUser: 'device-compute',
      setupComplexity: 'medium',
      operationalBurden: 'low',
      maxCapability: 'adequate',
      typicalLatency: { min: 50, max: 500 },
      offlineCapable: true,
      dataLeavesDevice: false,
      dataLeavesWRI: false,
      queryVisibility: 'none',
      customGuardrails: 'app-level',
      vendorLockIn: 'none',
      multiProvider: false,
    },
  },
  {
    id: 'hybrid',
    name: 'Hybrid',
    shortName: 'Hybrid',
    category: 'Hybrid',
    tagline: 'Intelligent routing between methods',
    description:
      'Combines multiple methods — e.g., edge for simple tasks, cloud for complex ones. Routes based on task complexity, connectivity, or cost.',
    bestFor: [
      'Products with varied task complexity',
      'Intermittent connectivity scenarios',
      'Optimizing cost vs. quality tradeoffs',
    ],
    redFlags: [
      'Complexity explosion in routing logic',
      'Harder to debug and monitor',
      'Multiple failure modes to handle',
    ],
    exampleServices: 'Custom routing layer',
    characteristics: {
      costToWRI: 'variable',
      costToUser: 'partial',
      setupComplexity: 'high',
      operationalBurden: 'medium',
      maxCapability: 'frontier',
      typicalLatency: { min: 50, max: 2000 },
      offlineCapable: true,
      dataLeavesDevice: true,
      dataLeavesWRI: true,
      queryVisibility: 'partial',
      customGuardrails: 'full',
      vendorLockIn: 'medium',
      multiProvider: true,
    },
  },
];

export const methodsById = new Map(methods.map((m) => [m.id, m]));

export function getMethod(id: string): DeliveryMethod | undefined {
  return methodsById.get(id as any);
}
